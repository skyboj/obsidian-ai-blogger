import { copyFile, mkdir, readdir, stat } from 'fs/promises';
import { join, dirname, resolve } from 'path';
import { logger } from './logger.js';

/**
 * –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –æ—Å–Ω–æ–≤–Ω—ã–º –±–ª–æ–≥–æ–≤—ã–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º Obsidian Blogger
 */
export class BlogIntegration {
    constructor(config = {}) {
        this.generatorOutputDir = config.generatorOutputDir || './output';
        this.blogFolderPath = config.blogFolderPath || '../obsidian-blogger/Blog';
        this.draftsSubfolder = config.draftsSubfolder || 'drafts';
        this.autoSync = config.autoSync || false;
        
        logger.debug('BlogIntegration initialized', {
            generatorOutputDir: this.generatorOutputDir,
            blogFolderPath: this.blogFolderPath,
            autoSync: this.autoSync
        });
    }

    /**
     * –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –≤ –ø–∞–ø–∫—É –±–ª–æ–≥–∞
     */
    async copyToBlogs(filePath, options = {}) {
        try {
            const {
                publishReady = false,
                subfolder = null,
                overwrite = false
            } = options;

            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–ª–µ–≤—É—é –ø–∞–ø–∫—É
            const targetFolder = publishReady 
                ? this.blogFolderPath 
                : join(this.blogFolderPath, this.draftsSubfolder);

            // –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω–∞ –ø–æ–¥–ø–∞–ø–∫–∞
            const finalTargetFolder = subfolder 
                ? join(targetFolder, subfolder) 
                : targetFolder;

            // –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            await this.ensureDirectoryExists(finalTargetFolder);

            // –ü–æ–ª—É—á–∞–µ–º –∏–º—è —Ñ–∞–π–ª–∞
            const fileName = filePath.split('/').pop();
            const targetPath = join(finalTargetFolder, fileName);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            if (!overwrite) {
                try {
                    await stat(targetPath);
                    logger.warn(`File already exists: ${targetPath}`);
                    return {
                        success: false,
                        error: 'FILE_EXISTS',
                        message: '–§–∞–π–ª —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ —Ü–µ–ª–µ–≤–æ–π –ø–∞–ø–∫–µ'
                    };
                } catch (error) {
                    // –§–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - —ç—Ç–æ —Ö–æ—Ä–æ—à–æ
                }
            }

            // –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª
            await copyFile(filePath, targetPath);

            const status = publishReady ? 'published' : 'draft';
            logger.success(`üìÑ Copied to blog (${status}): ${targetPath}`);

            return {
                success: true,
                sourcePath: filePath,
                targetPath,
                status,
                folder: finalTargetFolder
            };

        } catch (error) {
            logger.error('Failed to copy file to blog:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
     */
    async syncNewFiles() {
        try {
            logger.info('üîÑ Starting blog sync...');

            // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
            const generatorFiles = await this.getGeneratorFiles();
            
            // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –≤ –±–ª–æ–≥–µ
            const blogFiles = await this.getBlogFiles();

            // –ù–∞—Ö–æ–¥–∏–º –Ω–æ–≤—ã–µ —Ñ–∞–π–ª—ã
            const newFiles = generatorFiles.filter(genFile => {
                return !blogFiles.some(blogFile => 
                    blogFile.name === genFile.name
                );
            });

            if (newFiles.length === 0) {
                logger.info('‚ÑπÔ∏è No new files to sync');
                return {
                    success: true,
                    syncedFiles: [],
                    message: 'No new files found'
                };
            }

            logger.info(`üìã Found ${newFiles.length} new files to sync`);

            const syncResults = [];

            for (const file of newFiles) {
                const result = await this.copyToBlogs(file.path, {
                    publishReady: false, // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ —á–µ—Ä–Ω–æ–≤–∏–∫–∏
                    overwrite: false
                });

                syncResults.push({
                    fileName: file.name,
                    result
                });

                if (result.success) {
                    logger.info(`‚úÖ Synced: ${file.name}`);
                } else {
                    logger.warn(`‚ùå Failed to sync: ${file.name} - ${result.error}`);
                }
            }

            const successCount = syncResults.filter(r => r.result.success).length;
            
            logger.success(`üéâ Sync completed: ${successCount}/${newFiles.length} files synced`);

            return {
                success: true,
                syncedFiles: syncResults,
                totalFiles: newFiles.length,
                successCount
            };

        } catch (error) {
            logger.error('Sync failed:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * –ü—É–±–ª–∏–∫–∞—Ü–∏—è —á–µ—Ä–Ω–æ–≤–∏–∫–∞ (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∏–∑ drafts –≤ –æ—Å–Ω–æ–≤–Ω—É—é –ø–∞–ø–∫—É)
     */
    async publishDraft(fileName) {
        try {
            const draftPath = join(this.blogFolderPath, this.draftsSubfolder, fileName);
            const publishPath = join(this.blogFolderPath, fileName);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —á–µ—Ä–Ω–æ–≤–∏–∫–∞
            try {
                await stat(draftPath);
            } catch (error) {
                return {
                    success: false,
                    error: 'DRAFT_NOT_FOUND',
                    message: '–ß–µ—Ä–Ω–æ–≤–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'
                };
            }

            // –ö–æ–ø–∏—Ä—É–µ–º –≤ –æ—Å–Ω–æ–≤–Ω—É—é –ø–∞–ø–∫—É
            await copyFile(draftPath, publishPath);

            logger.success(`üì∞ Published: ${fileName}`);

            return {
                success: true,
                draftPath,
                publishPath,
                message: '–°—Ç–∞—Ç—å—è –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞'
            };

        } catch (error) {
            logger.error('Failed to publish draft:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤ –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
     */
    async getGeneratorFiles() {
        try {
            const files = [];
            const outputDir = resolve(this.generatorOutputDir);
            
            // –°–∫–∞–Ω–∏—Ä—É–µ–º output –ø–∞–ø–∫—É
            await this.scanDirectory(outputDir, files, '.md');
            
            // –°–∫–∞–Ω–∏—Ä—É–µ–º drafts –ø–∞–ø–∫—É
            const draftsDir = join(outputDir, 'drafts');
            try {
                await this.scanDirectory(draftsDir, files, '.md');
            } catch (error) {
                // –ü–∞–ø–∫–∞ drafts –º–æ–∂–µ—Ç –Ω–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å
            }

            return files;

        } catch (error) {
            logger.error('Failed to get generator files:', error);
            return [];
        }
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤ –∏–∑ –±–ª–æ–≥–∞
     */
    async getBlogFiles() {
        try {
            const files = [];
            const blogDir = resolve(this.blogFolderPath);
            
            // –°–∫–∞–Ω–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –ø–∞–ø–∫—É –±–ª–æ–≥–∞
            await this.scanDirectory(blogDir, files, '.md');
            
            // –°–∫–∞–Ω–∏—Ä—É–µ–º –ø–∞–ø–∫—É —á–µ—Ä–Ω–æ–≤–∏–∫–æ–≤
            const draftsDir = join(blogDir, this.draftsSubfolder);
            try {
                await this.scanDirectory(draftsDir, files, '.md');
            } catch (error) {
                // –ü–∞–ø–∫–∞ drafts –º–æ–∂–µ—Ç –Ω–µ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å
            }

            return files;

        } catch (error) {
            logger.error('Failed to get blog files:', error);
            return [];
        }
    }

    /**
     * –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
     */
    async scanDirectory(dirPath, files, extension) {
        try {
            const items = await readdir(dirPath, { withFileTypes: true });

            for (const item of items) {
                const fullPath = join(dirPath, item.name);

                if (item.isDirectory()) {
                    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å–∫–∞–Ω–∏—Ä—É–µ–º –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
                    await this.scanDirectory(fullPath, files, extension);
                } else if (item.isFile() && item.name.endsWith(extension)) {
                    const stats = await stat(fullPath);
                    files.push({
                        name: item.name,
                        path: fullPath,
                        size: stats.size,
                        modified: stats.mtime
                    });
                }
            }
        } catch (error) {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–ø–∫–∞–º
        }
    }

    /**
     * –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
     */
    async ensureDirectoryExists(dirPath) {
        try {
            await mkdir(dirPath, { recursive: true });
        } catch (error) {
            if (error.code !== 'EEXIST') {
                throw error;
            }
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –ø–∞–ø–∫–∏ –±–ª–æ–≥–∞
     */
    async checkBlogFolderAccess() {
        try {
            const blogPath = resolve(this.blogFolderPath);
            await stat(blogPath);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏ —Å–æ–∑–¥–∞–≤ —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª
            const testFile = join(blogPath, '.test-access');
            try {
                await copyFile(__filename, testFile);
                await stat(testFile);
                // –£–¥–∞–ª—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª
                await import('fs').then(fs => fs.promises.unlink(testFile));
                
                return {
                    accessible: true,
                    writable: true,
                    path: blogPath
                };
            } catch (error) {
                return {
                    accessible: true,
                    writable: false,
                    path: blogPath,
                    error: 'No write access'
                };
            }

        } catch (error) {
            return {
                accessible: false,
                writable: false,
                path: this.blogFolderPath,
                error: error.message
            };
        }
    }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
     */
    async getIntegrationStats() {
        try {
            const [generatorFiles, blogFiles, accessCheck] = await Promise.all([
                this.getGeneratorFiles(),
                this.getBlogFiles(),
                this.checkBlogFolderAccess()
            ]);

            const generatorCount = generatorFiles.length;
            const blogCount = blogFiles.length;
            
            // –ù–∞—Ö–æ–¥–∏–º –æ–±—â–∏–µ —Ñ–∞–π–ª—ã
            const commonFiles = generatorFiles.filter(genFile => 
                blogFiles.some(blogFile => blogFile.name === genFile.name)
            );

            return {
                generatorFiles: generatorCount,
                blogFiles: blogCount,
                commonFiles: commonFiles.length,
                newFiles: generatorCount - commonFiles.length,
                blogAccess: accessCheck,
                autoSync: this.autoSync
            };

        } catch (error) {
            logger.error('Failed to get integration stats:', error);
            return {
                error: error.message
            };
        }
    }

    /**
     * –°–æ–∑–¥–∞–Ω–∏–µ —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–æ–π —Å—Å—ã–ª–∫–∏ (–¥–ª—è –ø—Ä–æ–¥–≤–∏–Ω—É—Ç–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏)
     */
    async createSymlink() {
        try {
            const { symlink } = await import('fs').then(fs => fs.promises);
            const outputPath = resolve(this.generatorOutputDir);
            const linkPath = join(this.blogFolderPath, 'generated');

            await symlink(outputPath, linkPath, 'dir');

            logger.success(`üîó Created symlink: ${linkPath} -> ${outputPath}`);
            
            return {
                success: true,
                linkPath,
                targetPath: outputPath
            };

        } catch (error) {
            logger.error('Failed to create symlink:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }
} 