import { createAIManager } from '../ai/index.js';
import { PromptManager } from './promptManager.js';
import { MarkdownGenerator } from './markdownGenerator.js';
import { createImageManager } from '../media/index.js';
import { BlogIntegration } from '../utils/blogIntegration.js';
import { logger } from '../utils/logger.js';

/**
 * Основной генератор контента
 */
export class ContentGenerator {
    constructor(config) {
        this.config = config;
        this.aiManager = createAIManager(config.ai);
        this.promptManager = new PromptManager();
        this.markdownGenerator = new MarkdownGenerator(config.outputDir || './output');
        this.imageManager = createImageManager(config.images || {});
        this.blogIntegration = new BlogIntegration({
            generatorOutputDir: config.outputDir || './output',
            blogFolderPath: config.blogFolderPath || process.env.BLOG_FOLDER_PATH || '../obsidian-blogger/Blog',
            autoSync: config.autoSync || false
        });
        
        this.isInitialized = false;
    }

    /**
     * Initialization генератора
     */
    async initialize() {
        try {
            logger.info('🔧 Initializing Content Generator...');
            
            // Загрузка шаблонов промптов
            await this.promptManager.loadTemplates();
            
            // Check доступности AI провайдеров
            const healthChecks = await this.aiManager.checkProvidersHealth();
            const availableProviders = healthChecks.filter(check => check.available);
            
            if (availableProviders.length === 0) {
                throw new Error('No AI providers available');
            }
            
            logger.success(`✅ Content Generator initialized with ${availableProviders.length} AI provider(s)`);
            this.isInitialized = true;
            
        } catch (error) {
            logger.error('Failed to initialize Content Generator:', error);
            throw error;
        }
    }

    /**
     * Генерация статьи по теме
     */
    async generateArticle(options) {
        if (!this.isInitialized) {
            await this.initialize();
        }

        const {
            topic,
            template = 'default',
            variables = {},
            aiOptions = {},
            outputOptions = {}
        } = options;

        try {
            logger.info(`📝 Starting article generation for topic: "${topic}"`);
            
            // 1. Подготовка промпта из шаблона
            const promptData = this.promptManager.buildPrompt(template, {
                topic,
                ...variables
            });
            
            logger.info(`📋 Using template: ${template}`);
            logger.debug(`Prompt length: ${promptData.prompt.length} characters`);
            
            // 2. Генерация контента через AI
            const generationResult = await this.aiManager.generate(promptData.prompt, aiOptions);
            
            if (!generationResult.success) {
                throw new Error(`AI generation failed: ${generationResult.message}`);
            }
            
            logger.success(`🤖 Content generated by ${generationResult.provider}`);
            
            // 3. Creating frontmatter из шаблона
            const frontmatter = this.promptManager.buildFrontmatter(template, {
                topic,
                ...variables
            }, {
                // Дополнительные метаданные
                ai_provider: generationResult.provider,
                generation_date: new Date().toISOString(),
                word_count: this.countWords(generationResult.content),
                template_used: template
            });
            
            // 4. Creating Markdown файла
            const markdownResult = await this.markdownGenerator.createDraft(
                topic,
                generationResult.content,
                frontmatter
            );
            
            if (!markdownResult.success) {
                throw new Error(`Markdown generation failed: ${markdownResult.error}`);
            }
            
            logger.success(`📄 Article saved to: ${markdownResult.path}`);
            
            // 5. Возвращаем результат
            return {
                success: true,
                topic,
                template,
                file: {
                    path: markdownResult.path,
                    filename: markdownResult.filename,
                    size: markdownResult.size
                },
                content: {
                    text: generationResult.content,
                    wordCount: this.countWords(generationResult.content),
                    readingTime: this.estimateReadingTime(generationResult.content)
                },
                metadata: {
                    aiProvider: generationResult.provider,
                    model: generationResult.metadata.model,
                    tokensUsed: generationResult.metadata.tokensUsed,
                    generationTime: generationResult.metadata.timestamp,
                    frontmatter: markdownResult.frontmatter
                }
            };
            
        } catch (error) {
            logger.error('Article generation failed:', error);
            return {
                success: false,
                error: error.message,
                topic
            };
        }
    }

    /**
     * Генерация краткого описания статьи
     */
    async generateDescription(content, maxLength = 160) {
        try {
            const descriptionPrompt = `
Создай краткое и привлекательное описание для статьи (не более ${maxLength} символов).

Контент статьи:
${content.substring(0, 1000)}...

Требования к описанию:
- Максимум ${maxLength} символов
- Привлекательное и информативное
- Без кавычек
- На русском языке
- Призывает к прочтению

Верни только описание без дополнительного текста.`;

            const result = await this.aiManager.generate(descriptionPrompt, {
                maxTokens: 100,
                temperature: 0.7
            });

            if (result.success) {
                let description = result.content.trim();
                
                // Обрезаем если превышает лимит
                if (description.length > maxLength) {
                    description = description.substring(0, maxLength - 3) + '...';
                }
                
                return description;
            }
            
            return null;
            
        } catch (error) {
            logger.error('Failed to generate description:', error);
            return null;
        }
    }

    /**
     * Генерация тегов для статьи
     */
    async generateTags(topic, content, maxTags = 5) {
        try {
            const tagsPrompt = `
Создай ${maxTags} релевантных тегов для статьи на тему "${topic}".

Начало статьи:
${content.substring(0, 500)}...

Требования к тегам:
- Максимум ${maxTags} тегов
- На русском языке
- Одно-два слова каждый
- Релевантные теме и содержанию
- В нижнем регистре

Верни теги через запятую без дополнительного текста.`;

            const result = await this.aiManager.generate(tagsPrompt, {
                maxTokens: 50,
                temperature: 0.5
            });

            if (result.success) {
                const tags = result.content
                    .trim()
                    .split(',')
                    .map(tag => tag.trim().toLowerCase())
                    .filter(tag => tag.length > 0)
                    .slice(0, maxTags);
                
                return tags;
            }
            
            return [];
            
        } catch (error) {
            logger.error('Failed to generate tags:', error);
            return [];
        }
    }

    /**
     * Полная генерация статьи с автоматическими метаданными
     */
    async generateCompleteArticle(topic) {
        const result = await this.generateArticle({ topic });
        
        if (!result.success) {
            return result;
        }

        try {
            logger.info('🔍 Generating additional metadata...');
            
            // Генерируем описание, теги и изображение
            const [description, tags, imageResult] = await Promise.all([
                this.generateDescription(result.content.text),
                this.generateTags(result.topic, result.content.text),
                this.findImageForTopic(result.topic)
            ]);

            // Обновляем файл с новыми метаданными
            if (description || tags.length > 0 || (imageResult && imageResult.success)) {
                const updatedFrontmatter = {
                    ...result.metadata.frontmatter
                };

                if (description) {
                    updatedFrontmatter.description = description;
                }

                if (tags.length > 0) {
                    updatedFrontmatter.tags = [...(updatedFrontmatter.tags || []), ...tags];
                }

                if (imageResult && imageResult.success) {
                    updatedFrontmatter.featured_image = imageResult.image.url;
                    updatedFrontmatter.featured_image_alt = imageResult.image.title || imageResult.image.description;
                    
                    // Добавляем атрибуцию в метаданные
                    if (imageResult.image.author) {
                        updatedFrontmatter.image_author = imageResult.image.author;
                        updatedFrontmatter.image_source = imageResult.image.source;
                    }
                }

                const updateResult = await this.markdownGenerator.updateMarkdownFile(
                    result.file.path,
                    result.content.text,
                    updatedFrontmatter
                );

                if (updateResult.success) {
                    result.metadata.frontmatter = updatedFrontmatter;
                    logger.success('✨ Enhanced with auto-generated metadata');
                }
            }

            return result;
            
        } catch (error) {
            logger.warn('Failed to generate additional metadata:', error);
            return result; // Возвращаем базовый результат
        }
    }

    /**
     * Генерация статьи с прямой публикацией в блог
     */
    async generateAndPublishToBlog(options) {
        const result = await this.generateCompleteArticle(options);
        
        if (!result.success) {
            return result;
        }

        try {
            logger.info('📤 Publishing to blog...');
            
            // Копируем в папку блога
            const publishResult = await this.blogIntegration.copyToBlogs(result.file.path, {
                publishReady: options.publishReady || false,
                overwrite: options.overwrite || false
            });

            if (publishResult.success) {
                logger.success(`🎉 Article published to blog: ${publishResult.targetPath}`);
                
                return {
                    ...result,
                    blogPublication: publishResult,
                    published: true
                };
            } else {
                logger.warn(`❌ Failed to publish to blog: ${publishResult.message}`);
                
                return {
                    ...result,
                    blogPublication: publishResult,
                    published: false
                };
            }

        } catch (error) {
            logger.error('Failed to publish to blog:', error);
            return {
                ...result,
                published: false,
                error: error.message
            };
        }
    }

    /**
     * Синхронизация всех новых файлов с блогом
     */
    async syncWithBlog() {
        try {
            return await this.blogIntegration.syncNewFiles();
        } catch (error) {
            logger.error('Failed to sync with blog:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Draft publication
     */
    async publishDraft(fileName) {
        try {
            return await this.blogIntegration.publishDraft(fileName);
        } catch (error) {
            logger.error('Failed to publish draft:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Getting статистики интеграции с блогом
     */
    async getBlogIntegrationStats() {
        try {
            return await this.blogIntegration.getIntegrationStats();
        } catch (error) {
            logger.error('Failed to get blog stats:', error);
            return {
                error: error.message
            };
        }
    }

    /**
     * Поиск подходящего изображения для темы
     */
    async findImageForTopic(topic) {
        try {
            // Получаем ключевые слова из шаблона если возможно
            let keywords = [topic];
            
            try {
                const templateKeywords = this.promptManager.getImageKeywords('default', { topic });
                if (templateKeywords && templateKeywords.length > 0) {
                    keywords = templateKeywords;
                }
            } catch (error) {
                logger.debug('Could not get template keywords, using topic as keyword');
            }

            logger.info(`🖼️ Searching image for topic: "${topic}"`);

            const result = await this.imageManager.getBestImageForTopic(topic, {
                limit: 3,
                orientation: 'landscape',
                minWidth: 800,
                minHeight: 600
            });

            if (result.success) {
                logger.success(`✅ Found image: ${result.image.title || result.image.id}`);
                return result;
            } else {
                logger.warn(`❌ No suitable image found for topic: ${topic}`);
                return null;
            }

        } catch (error) {
            logger.error('Failed to find image for topic:', error);
            return null;
        }
    }

    /**
     * Getting доступных шаблонов
     */
    getAvailableTemplates() {
        return this.promptManager.getAvailableTemplates();
    }

    /**
     * Getting статуса AI провайдеров
     */
    async getProvidersStatus() {
        return this.aiManager.checkProvidersHealth();
    }

    /**
     * Подсчет слов в тексте
     */
    countWords(text) {
        return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }

    /**
     * Оценка времени чтения
     */
    estimateReadingTime(text) {
        const wordsPerMinute = 200;
        const wordCount = this.countWords(text);
        const minutes = Math.ceil(wordCount / wordsPerMinute);
        
        return {
            minutes,
            words: wordCount,
            text: minutes === 1 ? '1 минута' : `${minutes} минут`
        };
    }

    /**
     * Getting статистики генерации
     */
    getGenerationStats() {
        return {
            aiProviders: this.aiManager.getAvailableProviders(),
            templates: this.promptManager.getAvailableTemplates().length,
            usage: this.aiManager.getUsageStats()
        };
    }
} 