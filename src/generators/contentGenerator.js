import { createAIManager } from '../ai/index.js';
import { PromptManager } from './promptManager.js';
import { MarkdownGenerator } from './markdownGenerator.js';
import { createImageManager } from '../media/index.js';
import { BlogIntegration } from '../utils/blogIntegration.js';
import { logger } from '../utils/logger.js';

/**
 * –û—Å–Ω–æ–≤–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞
 */
export class ContentGenerator {
    constructor(config) {
        this.config = config;
        this.aiManager = createAIManager(config.ai);
        this.promptManager = new PromptManager();
        this.markdownGenerator = new MarkdownGenerator(config.outputDir || './output');
        this.imageManager = createImageManager(config.images || {});
        this.blogIntegration = new BlogIntegration({
            generatorOutputDir: config.outputDir || './output',
            blogFolderPath: config.blogFolderPath || process.env.BLOG_FOLDER_PATH || '../obsidian-blogger/Blog',
            autoSync: config.autoSync || false
        });
        
        this.isInitialized = false;
    }

    /**
     * Initialization –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
     */
    async initialize() {
        try {
            logger.info('üîß Initializing Content Generator...');
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –ø—Ä–æ–º–ø—Ç–æ–≤
            await this.promptManager.loadTemplates();
            
            // Check –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
            const healthChecks = await this.aiManager.checkProvidersHealth();
            const availableProviders = healthChecks.filter(check => check.available);
            
            if (availableProviders.length === 0) {
                throw new Error('No AI providers available');
            }
            
            logger.success(`‚úÖ Content Generator initialized with ${availableProviders.length} AI provider(s)`);
            this.isInitialized = true;
            
        } catch (error) {
            logger.error('Failed to initialize Content Generator:', error);
            throw error;
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç—å–∏ –ø–æ —Ç–µ–º–µ
     */
    async generateArticle(options) {
        if (!this.isInitialized) {
            await this.initialize();
        }

        const {
            topic,
            template = 'default',
            variables = {},
            aiOptions = {},
            outputOptions = {}
        } = options;

        try {
            logger.info(`üìù Starting article generation for topic: "${topic}"`);
            
            // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Ä–æ–º–ø—Ç–∞ –∏–∑ —à–∞–±–ª–æ–Ω–∞
            const promptData = this.promptManager.buildPrompt(template, {
                topic,
                ...variables
            });
            
            logger.info(`üìã Using template: ${template}`);
            logger.debug(`Prompt length: ${promptData.prompt.length} characters`);
            
            // 2. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ AI
            const generationResult = await this.aiManager.generate(promptData.prompt, aiOptions);
            
            if (!generationResult.success) {
                throw new Error(`AI generation failed: ${generationResult.message}`);
            }
            
            logger.success(`ü§ñ Content generated by ${generationResult.provider}`);
            
            // 3. Creating frontmatter –∏–∑ —à–∞–±–ª–æ–Ω–∞
            const frontmatter = this.promptManager.buildFrontmatter(template, {
                topic,
                ...variables
            }, {
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
                ai_provider: generationResult.provider,
                generation_date: new Date().toISOString(),
                word_count: this.countWords(generationResult.content),
                template_used: template
            });
            
            // 4. Creating Markdown —Ñ–∞–π–ª–∞
            const markdownResult = await this.markdownGenerator.createDraft(
                topic,
                generationResult.content,
                frontmatter
            );
            
            if (!markdownResult.success) {
                throw new Error(`Markdown generation failed: ${markdownResult.error}`);
            }
            
            logger.success(`üìÑ Article saved to: ${markdownResult.path}`);
            
            // 5. –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            return {
                success: true,
                topic,
                template,
                file: {
                    path: markdownResult.path,
                    filename: markdownResult.filename,
                    size: markdownResult.size
                },
                content: {
                    text: generationResult.content,
                    wordCount: this.countWords(generationResult.content),
                    readingTime: this.estimateReadingTime(generationResult.content)
                },
                metadata: {
                    aiProvider: generationResult.provider,
                    model: generationResult.metadata.model,
                    tokensUsed: generationResult.metadata.tokensUsed,
                    generationTime: generationResult.metadata.timestamp,
                    frontmatter: markdownResult.frontmatter
                }
            };
            
        } catch (error) {
            logger.error('Article generation failed:', error);
            return {
                success: false,
                error: error.message,
                topic
            };
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∞—Ç–∫–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ç–∞—Ç—å–∏
     */
    async generateDescription(content, maxLength = 160) {
        try {
            const descriptionPrompt = `
Create a brief and engaging description for the article (no more than ${maxLength} characters).

Article content:
${content.substring(0, 1000)}...

Description requirements:
- Maximum ${maxLength} characters
- Engaging and informative
- No quotes
- In English
- Encourages reading

Return only the description without additional text.`;

            const result = await this.aiManager.generate(descriptionPrompt, {
                maxTokens: 100,
                temperature: 0.7
            });

            if (result.success) {
                let description = result.content.trim();
                
                // –û–±—Ä–µ–∑–∞–µ–º –µ—Å–ª–∏ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç
                if (description.length > maxLength) {
                    description = description.substring(0, maxLength - 3) + '...';
                }
                
                return description;
            }
            
            return null;
            
        } catch (error) {
            logger.error('Failed to generate description:', error);
            return null;
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–≥–æ–≤ –¥–ª—è —Å—Ç–∞—Ç—å–∏
     */
    async generateTags(topic, content, maxTags = 5) {
        try {
            const tagsPrompt = `
Create ${maxTags} relevant tags for an article on the topic "${topic}".

Beginning of the article:
${content.substring(0, 500)}...

Tag requirements:
- Maximum ${maxTags} tags
- In English
- One or two words each
- Relevant to the topic and content
- In lowercase

Return the tags separated by commas without additional text.`;

            const result = await this.aiManager.generate(tagsPrompt, {
                maxTokens: 50,
                temperature: 0.5
            });

            if (result.success) {
                const tags = result.content
                    .trim()
                    .split(',')
                    .map(tag => tag.trim().toLowerCase())
                    .filter(tag => tag.length > 0)
                    .slice(0, maxTags);
                
                return tags;
            }
            
            return [];
            
        } catch (error) {
            logger.error('Failed to generate tags:', error);
            return [];
        }
    }

    /**
     * Generates a new, engaging title for the article
     */
    async generateTitle(originalTopic, content) {
        try {
            const titlePrompt = `
Your first task is to translate the following topic from its original language into English.
Original topic: "${originalTopic}"

Your second task is to take the English translation and rephrase it into a new, creative, and SEO-friendly title for a blog post.

The new title must meet these requirements:
- Be in English.
- Be catchy, engaging, and optimized for search engines.
- Accurately reflect the article's content, which starts with: ${content.substring(0, 1000)}...
- Do not use quotes in the title.

Return ONLY the final, rephrased English title. Do not include the initial translation or any other extra text.
            `;

            const result = await this.aiManager.generate(titlePrompt, {
                maxTokens: 60,
                temperature: 0.8
            });

            if (result.success && result.content) {
                return result.content.trim().replace(/"/g, ''); // Remove quotes
            }

            return originalTopic; // Fallback to original topic
        } catch (error) {
            logger.error('Failed to generate title:', error);
            return originalTopic; // Fallback to original topic
        }
    }

    /**
     * –ü–æ–ª–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç—å–∏ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
     */
    async generateCompleteArticle(topic) {
        const result = await this.generateArticle({ topic });
        
        if (!result.success) {
            return result;
        }

        try {
            logger.info('üîç Generating additional metadata...');
            
            // Generate description and tags in parallel
            const [description, tags, newTitle] = await Promise.all([
                this.generateDescription(result.content.text),
                this.generateTags(result.topic, result.content.text),
                this.generateTitle(result.topic, result.content.text)
            ]);
            
            logger.success('‚ú® Generated additional metadata');

            const existingTags = result.metadata.frontmatter.tags || [];
            const allTags = [...new Set([...existingTags, ...tags])];

            // Update the markdown file with the new metadata
            const updatedArticle = await this.markdownGenerator.updateDraft(
                result.file.filename,
                {
                    title: newTitle,
                    description: description,
                    tags: allTags,
                    publish: false // Ensure it remains a draft
                }
            );
            
            if (!updatedArticle.success) {
                throw new Error('Failed to update draft with new metadata.');
            }
            
            logger.success(`‚úÖ Updated draft: ${updatedArticle.filename}`);
            
            return {
                ...result,
                title: newTitle, // Return the new title
                filename: updatedArticle.filename // Return the new filename (slug might have changed)
            };
            
        } catch (error) {
            logger.error('Failed to generate complete article metadata:', error);
            // Return the original result without metadata
            return result;
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç—å–∏ —Å –ø—Ä—è–º–æ–π –ø—É–±–ª–∏–∫–∞—Ü–∏–µ–π –≤ –±–ª–æ–≥
     */
    async generateAndPublishToBlog(options) {
        const result = await this.generateCompleteArticle(options);
        
        if (!result.success) {
            return result;
        }

        try {
            logger.info('üì§ Publishing to blog...');
            
            // –ö–æ–ø–∏—Ä—É–µ–º –≤ –ø–∞–ø–∫—É –±–ª–æ–≥–∞
            const publishResult = await this.blogIntegration.copyToBlogs(result.file.path, {
                publishReady: options.publishReady || false,
                overwrite: options.overwrite || false
            });

            if (publishResult.success) {
                logger.success(`üéâ Article published to blog: ${publishResult.targetPath}`);
                
                return {
                    ...result,
                    blogPublication: publishResult,
                    published: true
                };
            } else {
                logger.warn(`‚ùå Failed to publish to blog: ${publishResult.message}`);
                
                return {
                    ...result,
                    blogPublication: publishResult,
                    published: false
                };
            }

        } catch (error) {
            logger.error('Failed to publish to blog:', error);
            return {
                ...result,
                published: false,
                error: error.message
            };
        }
    }

    /**
     * –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ —Å –±–ª–æ–≥–æ–º
     */
    async syncWithBlog() {
        try {
            return await this.blogIntegration.syncNewFiles();
        } catch (error) {
            logger.error('Failed to sync with blog:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Draft publication
     */
    async publishDraft(fileName) {
        try {
            return await this.blogIntegration.publishDraft(fileName);
        } catch (error) {
            logger.error('Failed to publish draft:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Getting —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –±–ª–æ–≥–æ–º
     */
    async getBlogIntegrationStats() {
        try {
            return await this.blogIntegration.getIntegrationStats();
        } catch (error) {
            logger.error('Failed to get blog stats:', error);
            return {
                error: error.message
            };
        }
    }

    /**
     * –ü–æ–∏—Å–∫ –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ç–µ–º—ã
     */
    async findImageForTopic(topic) {
        try {
            // –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ —à–∞–±–ª–æ–Ω–∞ –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
            let keywords = [topic];
            
            try {
                const templateKeywords = this.promptManager.getImageKeywords('default', { topic });
                if (templateKeywords && templateKeywords.length > 0) {
                    keywords = templateKeywords;
                }
            } catch (error) {
                logger.debug('Could not get template keywords, using topic as keyword');
            }

            logger.info(`üñºÔ∏è Searching image for topic: "${topic}"`);

            const result = await this.imageManager.getBestImageForTopic(topic, {
                limit: 3,
                orientation: 'landscape',
                minWidth: 800,
                minHeight: 600
            });

            if (result.success) {
                logger.success(`‚úÖ Found image: ${result.image.title || result.image.id}`);
                return result;
            } else {
                logger.warn(`‚ùå No suitable image found for topic: ${topic}`);
                return null;
            }

        } catch (error) {
            logger.error('Failed to find image for topic:', error);
            return null;
        }
    }

    /**
     * Getting –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —à–∞–±–ª–æ–Ω–æ–≤
     */
    getAvailableTemplates() {
        return this.promptManager.getAvailableTemplates();
    }

    /**
     * Getting —Å—Ç–∞—Ç—É—Å–∞ AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
     */
    async getProvidersStatus() {
        return this.aiManager.checkProvidersHealth();
    }

    /**
     * –ü–æ–¥—Å—á–µ—Ç —Å–ª–æ–≤ –≤ —Ç–µ–∫—Å—Ç–µ
     */
    countWords(text) {
        return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }

    /**
     * –û—Ü–µ–Ω–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —á—Ç–µ–Ω–∏—è
     */
    estimateReadingTime(text) {
        const wordsPerMinute = 200;
        const wordCount = this.countWords(text);
        const minutes = Math.ceil(wordCount / wordsPerMinute);
        
        return {
            minutes,
            words: wordCount,
            text: minutes === 1 ? '1 minute' : `${minutes} minutes`
        };
    }

    /**
     * Getting —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
     */
    getGenerationStats() {
        return {
            aiProviders: this.aiManager.getAvailableProviders(),
            templates: this.promptManager.getAvailableTemplates().length,
            usage: this.aiManager.getUsageStats()
        };
    }
} 