import { createAIManager } from '../ai/index.js';
import { PromptManager } from './promptManager.js';
import { MarkdownGenerator } from './markdownGenerator.js';
import { createImageManager } from '../media/index.js';
import { BlogIntegration } from '../utils/blogIntegration.js';
import { logger } from '../utils/logger.js';

/**
 * –û—Å–Ω–æ–≤–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞
 */
export class ContentGenerator {
    constructor(config) {
        this.config = config;
        this.aiManager = createAIManager(config.ai);
        this.promptManager = new PromptManager();
        this.markdownGenerator = new MarkdownGenerator(config.outputDir || './output');
        this.imageManager = createImageManager(config.images || {});
        this.blogIntegration = new BlogIntegration({
            generatorOutputDir: config.outputDir || './output',
            blogFolderPath: config.blogFolderPath || process.env.BLOG_FOLDER_PATH || '../obsidian-blogger/Blog',
            autoSync: config.autoSync || false
        });
        
        this.isInitialized = false;
    }

    /**
     * Initialization –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
     */
    async initialize() {
        try {
            logger.info('üîß Initializing Content Generator...');
            
            // –ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤ –ø—Ä–æ–º–ø—Ç–æ–≤
            await this.promptManager.loadTemplates();
            
            // Check –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
            const healthChecks = await this.aiManager.checkProvidersHealth();
            const availableProviders = healthChecks.filter(check => check.available);
            
            if (availableProviders.length === 0) {
                throw new Error('No AI providers available');
            }
            
            logger.success(`‚úÖ Content Generator initialized with ${availableProviders.length} AI provider(s)`);
            this.isInitialized = true;
            
        } catch (error) {
            logger.error('Failed to initialize Content Generator:', error);
            throw error;
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç—å–∏ –ø–æ —Ç–µ–º–µ
     */
    async generateArticle(options) {
        if (!this.isInitialized) {
            await this.initialize();
        }

        const {
            topic,
            template = 'default',
            variables = {},
            aiOptions = {},
            outputOptions = {}
        } = options;

        try {
            logger.info(`üìù Starting article generation for topic: "${topic}"`);
            
            // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Ä–æ–º–ø—Ç–∞ –∏–∑ —à–∞–±–ª–æ–Ω–∞
            const promptData = this.promptManager.buildPrompt(template, {
                topic,
                ...variables
            });
            
            logger.info(`üìã Using template: ${template}`);
            logger.debug(`Prompt length: ${promptData.prompt.length} characters`);
            
            // 2. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ AI
            const generationResult = await this.aiManager.generate(promptData.prompt, aiOptions);
            
            if (!generationResult.success) {
                throw new Error(`AI generation failed: ${generationResult.message}`);
            }
            
            logger.success(`ü§ñ Content generated by ${generationResult.provider}`);
            
            // 3. Creating frontmatter –∏–∑ —à–∞–±–ª–æ–Ω–∞
            const frontmatter = this.promptManager.buildFrontmatter(template, {
                topic,
                ...variables
            }, {
                // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
                ai_provider: generationResult.provider,
                generation_date: new Date().toISOString(),
                word_count: this.countWords(generationResult.content),
                template_used: template
            });
            
            // 4. Creating Markdown —Ñ–∞–π–ª–∞
            const markdownResult = await this.markdownGenerator.createDraft(
                topic,
                generationResult.content,
                frontmatter
            );
            
            if (!markdownResult.success) {
                throw new Error(`Markdown generation failed: ${markdownResult.error}`);
            }
            
            logger.success(`üìÑ Article saved to: ${markdownResult.path}`);
            
            // 5. –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            return {
                success: true,
                topic,
                template,
                file: {
                    path: markdownResult.path,
                    filename: markdownResult.filename,
                    size: markdownResult.size
                },
                content: {
                    text: generationResult.content,
                    wordCount: this.countWords(generationResult.content),
                    readingTime: this.estimateReadingTime(generationResult.content)
                },
                metadata: {
                    aiProvider: generationResult.provider,
                    model: generationResult.metadata.model,
                    tokensUsed: generationResult.metadata.tokensUsed,
                    generationTime: generationResult.metadata.timestamp,
                    frontmatter: markdownResult.frontmatter
                }
            };
            
        } catch (error) {
            logger.error('Article generation failed:', error);
            return {
                success: false,
                error: error.message,
                topic
            };
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∞—Ç–∫–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è —Å—Ç–∞—Ç—å–∏
     */
    async generateDescription(content, maxLength = 160) {
        try {
            const descriptionPrompt = `
–°–æ–∑–¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ –∏ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è —Å—Ç–∞—Ç—å–∏ (–Ω–µ –±–æ–ª–µ–µ ${maxLength} —Å–∏–º–≤–æ–ª–æ–≤).

–ö–æ–Ω—Ç–µ–Ω—Ç —Å—Ç–∞—Ç—å–∏:
${content.substring(0, 1000)}...

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –æ–ø–∏—Å–∞–Ω–∏—é:
- –ú–∞–∫—Å–∏–º—É–º ${maxLength} —Å–∏–º–≤–æ–ª–æ–≤
- –ü—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ–µ
- –ë–µ–∑ –∫–∞–≤—ã—á–µ–∫
- –ù–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ
- –ü—Ä–∏–∑—ã–≤–∞–µ—Ç –∫ –ø—Ä–æ—á—Ç–µ–Ω–∏—é

–í–µ—Ä–Ω–∏ —Ç–æ–ª—å–∫–æ –æ–ø–∏—Å–∞–Ω–∏–µ –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.`;

            const result = await this.aiManager.generate(descriptionPrompt, {
                maxTokens: 100,
                temperature: 0.7
            });

            if (result.success) {
                let description = result.content.trim();
                
                // –û–±—Ä–µ–∑–∞–µ–º –µ—Å–ª–∏ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç
                if (description.length > maxLength) {
                    description = description.substring(0, maxLength - 3) + '...';
                }
                
                return description;
            }
            
            return null;
            
        } catch (error) {
            logger.error('Failed to generate description:', error);
            return null;
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–≥–æ–≤ –¥–ª—è —Å—Ç–∞—Ç—å–∏
     */
    async generateTags(topic, content, maxTags = 5) {
        try {
            const tagsPrompt = `
–°–æ–∑–¥–∞–π ${maxTags} —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö —Ç–µ–≥–æ–≤ –¥–ª—è —Å—Ç–∞—Ç—å–∏ –Ω–∞ —Ç–µ–º—É "${topic}".

–ù–∞—á–∞–ª–æ —Å—Ç–∞—Ç—å–∏:
${content.substring(0, 500)}...

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ —Ç–µ–≥–∞–º:
- –ú–∞–∫—Å–∏–º—É–º ${maxTags} —Ç–µ–≥–æ–≤
- –ù–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ
- –û–¥–Ω–æ-–¥–≤–∞ —Å–ª–æ–≤–∞ –∫–∞–∂–¥—ã–π
- –†–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–µ —Ç–µ–º–µ –∏ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏—é
- –í –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ

–í–µ—Ä–Ω–∏ —Ç–µ–≥–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é –±–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞.`;

            const result = await this.aiManager.generate(tagsPrompt, {
                maxTokens: 50,
                temperature: 0.5
            });

            if (result.success) {
                const tags = result.content
                    .trim()
                    .split(',')
                    .map(tag => tag.trim().toLowerCase())
                    .filter(tag => tag.length > 0)
                    .slice(0, maxTags);
                
                return tags;
            }
            
            return [];
            
        } catch (error) {
            logger.error('Failed to generate tags:', error);
            return [];
        }
    }

    /**
     * –ü–æ–ª–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç—å–∏ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
     */
    async generateCompleteArticle(topic) {
        const result = await this.generateArticle({ topic });
        
        if (!result.success) {
            return result;
        }

        try {
            logger.info('üîç Generating additional metadata...');
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ, —Ç–µ–≥–∏ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            const [description, tags, imageResult] = await Promise.all([
                this.generateDescription(result.content.text),
                this.generateTags(result.topic, result.content.text),
                this.findImageForTopic(result.topic)
            ]);

            // –û–±–Ω–æ–≤–ª—è–µ–º —Ñ–∞–π–ª —Å –Ω–æ–≤—ã–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
            if (description || tags.length > 0 || (imageResult && imageResult.success)) {
                const updatedFrontmatter = {
                    ...result.metadata.frontmatter
                };

                if (description) {
                    updatedFrontmatter.description = description;
                }

                if (tags.length > 0) {
                    updatedFrontmatter.tags = [...(updatedFrontmatter.tags || []), ...tags];
                }

                if (imageResult && imageResult.success) {
                    updatedFrontmatter.featured_image = imageResult.image.url;
                    updatedFrontmatter.featured_image_alt = imageResult.image.title || imageResult.image.description;
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –∞—Ç—Ä–∏–±—É—Ü–∏—é –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
                    if (imageResult.image.author) {
                        updatedFrontmatter.image_author = imageResult.image.author;
                        updatedFrontmatter.image_source = imageResult.image.source;
                    }
                }

                const updateResult = await this.markdownGenerator.updateMarkdownFile(
                    result.file.path,
                    result.content.text,
                    updatedFrontmatter
                );

                if (updateResult.success) {
                    result.metadata.frontmatter = updatedFrontmatter;
                    logger.success('‚ú® Enhanced with auto-generated metadata');
                }
            }

            return result;
            
        } catch (error) {
            logger.warn('Failed to generate additional metadata:', error);
            return result; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        }
    }

    /**
     * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç—å–∏ —Å –ø—Ä—è–º–æ–π –ø—É–±–ª–∏–∫–∞—Ü–∏–µ–π –≤ –±–ª–æ–≥
     */
    async generateAndPublishToBlog(options) {
        const result = await this.generateCompleteArticle(options);
        
        if (!result.success) {
            return result;
        }

        try {
            logger.info('üì§ Publishing to blog...');
            
            // –ö–æ–ø–∏—Ä—É–µ–º –≤ –ø–∞–ø–∫—É –±–ª–æ–≥–∞
            const publishResult = await this.blogIntegration.copyToBlogs(result.file.path, {
                publishReady: options.publishReady || false,
                overwrite: options.overwrite || false
            });

            if (publishResult.success) {
                logger.success(`üéâ Article published to blog: ${publishResult.targetPath}`);
                
                return {
                    ...result,
                    blogPublication: publishResult,
                    published: true
                };
            } else {
                logger.warn(`‚ùå Failed to publish to blog: ${publishResult.message}`);
                
                return {
                    ...result,
                    blogPublication: publishResult,
                    published: false
                };
            }

        } catch (error) {
            logger.error('Failed to publish to blog:', error);
            return {
                ...result,
                published: false,
                error: error.message
            };
        }
    }

    /**
     * –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ —Å –±–ª–æ–≥–æ–º
     */
    async syncWithBlog() {
        try {
            return await this.blogIntegration.syncNewFiles();
        } catch (error) {
            logger.error('Failed to sync with blog:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Draft publication
     */
    async publishDraft(fileName) {
        try {
            return await this.blogIntegration.publishDraft(fileName);
        } catch (error) {
            logger.error('Failed to publish draft:', error);
            return {
                success: false,
                error: error.message
            };
        }
    }

    /**
     * Getting —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –±–ª–æ–≥–æ–º
     */
    async getBlogIntegrationStats() {
        try {
            return await this.blogIntegration.getIntegrationStats();
        } catch (error) {
            logger.error('Failed to get blog stats:', error);
            return {
                error: error.message
            };
        }
    }

    /**
     * –ü–æ–∏—Å–∫ –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–ª—è —Ç–µ–º—ã
     */
    async findImageForTopic(topic) {
        try {
            // –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –∏–∑ —à–∞–±–ª–æ–Ω–∞ –µ—Å–ª–∏ –≤–æ–∑–º–æ–∂–Ω–æ
            let keywords = [topic];
            
            try {
                const templateKeywords = this.promptManager.getImageKeywords('default', { topic });
                if (templateKeywords && templateKeywords.length > 0) {
                    keywords = templateKeywords;
                }
            } catch (error) {
                logger.debug('Could not get template keywords, using topic as keyword');
            }

            logger.info(`üñºÔ∏è Searching image for topic: "${topic}"`);

            const result = await this.imageManager.getBestImageForTopic(topic, {
                limit: 3,
                orientation: 'landscape',
                minWidth: 800,
                minHeight: 600
            });

            if (result.success) {
                logger.success(`‚úÖ Found image: ${result.image.title || result.image.id}`);
                return result;
            } else {
                logger.warn(`‚ùå No suitable image found for topic: ${topic}`);
                return null;
            }

        } catch (error) {
            logger.error('Failed to find image for topic:', error);
            return null;
        }
    }

    /**
     * Getting –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —à–∞–±–ª–æ–Ω–æ–≤
     */
    getAvailableTemplates() {
        return this.promptManager.getAvailableTemplates();
    }

    /**
     * Getting —Å—Ç–∞—Ç—É—Å–∞ AI –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤
     */
    async getProvidersStatus() {
        return this.aiManager.checkProvidersHealth();
    }

    /**
     * –ü–æ–¥—Å—á–µ—Ç —Å–ª–æ–≤ –≤ —Ç–µ–∫—Å—Ç–µ
     */
    countWords(text) {
        return text.trim().split(/\s+/).filter(word => word.length > 0).length;
    }

    /**
     * –û—Ü–µ–Ω–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —á—Ç–µ–Ω–∏—è
     */
    estimateReadingTime(text) {
        const wordsPerMinute = 200;
        const wordCount = this.countWords(text);
        const minutes = Math.ceil(wordCount / wordsPerMinute);
        
        return {
            minutes,
            words: wordCount,
            text: minutes === 1 ? '1 –º–∏–Ω—É—Ç–∞' : `${minutes} –º–∏–Ω—É—Ç`
        };
    }

    /**
     * Getting —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
     */
    getGenerationStats() {
        return {
            aiProviders: this.aiManager.getAvailableProviders(),
            templates: this.promptManager.getAvailableTemplates().length,
            usage: this.aiManager.getUsageStats()
        };
    }
} 